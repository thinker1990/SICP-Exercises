#lang racket

(define (list->tree items) 
  (car (partial-tree items (length items))))

(define (partial-tree items n) 
  (if (= n 0) 
      (cons '() items)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree items left-size)))
          (let ((left-tree (car left-result))
                (non-left-items (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-items))
                  (right-result (partial-tree (cdr non-left-items) right-size)))
              (let ((right-tree (car right-result))
                    (remaining-items (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree) 
                      remaining-items))))))))


;; a. partial-tree works as follows:
;;    1. makes a recursive call which returns:
;;       a tree of the first half of the sorted list
;;       the remaining items of the initial list
;;    2. select the first of the remaining items to form the root of the complete tree
;;    3. make a recursive call with the (n - (left size) - 1) items.
;; The items generated by 1,2 and 3 are used to construct a tree made of first n items in the initial list.

(list->tree (list 1 3 5 7 9 11))  ;; '(5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))

;; b. 1. Each step reduces the problem set by half, so the reduce take log n steps.
;;    2. After reducing, each entry need to call make-tree to make a node of tree, so it take n steps.
;;    The total steps is: (log n) + n. so the order of growth is O(n).  
